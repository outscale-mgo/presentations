#!/bin/bash

slide()
{
    txt="$@"
    clear
    echo -e "$txt" | ponysay +f gnupony
    read
}

slide "so let's start by the begining...\n" "what's a package ?\n" "is it a binary\n" "what's a binary\n" "what is code?\n" "how is a program executed\n"

clear
cat <<EOF
                                                             Some stuff about memory
0x00000000
-----
|Ker|
|el |
|---| <--- that's my computer RAM, and this is where my programs are store when executed...
|Sys|		in the old days program used to have access to the whole computer memory.
|tem|
|D  |
|---|
|ZSH|
|   |						But in the futur when Zeta Gundam air on TV (1985) we create virtual memory
|---|
|Ema|
|cs |						      Let me show you:
|---|	             That's my computer memory
|Pul|					      \_____ 	 00 <--- that's the beginning of my memory
|sau|						    \__ ----
|dio|						       \|  |
|   |						 2048 ->|--|
|   |							|Pr| < that's where my program is store in the ram
|   |							|  |   between adress 2048 and 6144, it's the program physical memory
-----						 6144 ->|--|
0xffffffff					        ----
						        8192
EOF
read
cat <<EOF
									  But my program think its memory look like this, it's the memory it manipulate
															   /      so this whole fake memory,
												 00			  /       is its "Virtual memory"
												----			 /
												|Pr|  <------------------
												|og|
												|Da|
												|Ta|
												|  |
											        ----
											        8192

							This is the diference between Physicall and Virtual Memory
							If anything remmenber 1 thing: programs on modern architecture, run on they own memory space,
							thinking they are alone.





						    (Note: for simplification, I'll ignore CPU mechanisme here)
EOF
read

clear
cat <<EOF

		     How I imagine a CPU reading instructions
   ---------------------------oo----oo--------------------------------------------------
		               \[IP]/
			         \/
    -----------------------------|------------------------------------------------------
   /000/000/000/000/001/101/010/ V /110/001/110/010/110/110/000/000/000/000/000/000/000/ <- Memory content, mix of instructions and data.
  /___/___/___/___/___/___/___/___/___/___/__ /___/___/___/___/___/___/___/___/___/___/
   00  01  02  03  04  05  06  07  10  11  12  13  14  15  16  17  20  21  22  23  24  <- Memory adress

EOF
read

cat <<EOF

Back in the modern days of Slayers Try airing on TV (the 90s)
Let's look at what some program VM (Virtual Memory) may look like:

-----																	  -----
|   |																	  |   |
|   |																	  |   |
|Dta|																	  |R  |
|---|																	  |---|
|Ins|																	  |R E|
|Ins|																	  |R E|
|---|																	  |---|
|   |  <---- memory, contain Data, and instructions in the same memory.                          					  |   |
|Dta|		       because CPU aknowledge that developer are inferior to machines, that add permision on they memory		  |RW |
|   |																	  |   |
|---|																	  |---|
|Ins|																	  |R E|
|---|																	  |---|
|   |																	  |   |
|   | Ins: Instructions															  |   |
|   | Dta: Data										        The same memory with it's permision ->    |   |
-----												R: read W: write E: exec          	  -----


EOF
read


cat <<EOF

     But program are store in files (not RAM), so what if we store Raw code in a file:

     File containing Raw code (let's call it program.COM)
       /
      V
    ______                             --------RAM--------
   /Code /  ----> [load in memory] -->  |              |
  /File /                               | [ File Here] | <-- It's load, but what about Memory permision ?
 /     /                                |              |     Also, what about libraries ? It's just RAW code.
 ------                                -------------------

EOF
read

cat <<EOF
 If your programs, contain only code:
 - it doesn't contain memory permisions
 - no information how to load lib.
 syscall are usable, calling code from kernel is made using CPU instructions (int 0x80/sysenter/syscall)
EOF

cat <<EOF
 If you wonder, yes you could make a program like this.

   [kenrel load program] ->   -------- -> [program set up permision] -> --------  -> [load lib + prog ] ->  --------
			      | ins  |				        | ins  |			    | Wine |
			      |  RWE |				        |  R E |			    |----- |
			      | Data |				        | Data |			    | DLL  |
			      |  RWE |				        |  RW  |			    |------|
			      --------				        --------			    |XD.exe|
													    |      |
													    |      |
													    |      |
													    --------
 But then it need to be call like this:
 wine [wine ARG] XD.exe [XD ARG]
 or like this
 php kattarshians.php


EOF
read

cat <<EOF
                        /----------------------------------------- \\
                        | I'm ELF, Linux Executable Format Protocol|
                        | My job is to contain every information   |
			| The OS need to load a binary             |
                ___,@   \------------------------------------------/
               /  <         /
          ,_  /    \  _,   /
      ?    \'/______\'/   /                   ------
   ,_(_).  |; (e  e) ;|  /	            / ELF   /
    \___ \ \/\   7  /\/ /  _\8/_           / STUFF /
        \/\   \'=='/---/  | /| /|         /------ /
         \ \___)--(_______|//|//|        / CODE  /
          \___  ()  _____/|/_|/_|       /       /
             /  ()  \    '----'	        -------
            /   ()   \				 Elf have typically 2 implementation:
           '-.______.-'				 1 minimal implem inside the kernel itself:
         _    |_||_|    _			 - use with execve
        (@____) || (____@)			 - can not load libraries
         \______||______/			 1 more complex in userland:
						 - implemented inside the libc (/lib/ld-linux.so.2)
						 - can load lib, and do versioning
						 - load the libc as a minimal runtime for your program

						 When execve is call (ex ./my_program), kernel look at begining './my_program'
						 if it's a script, call the interpretter.
						 if it's an elf, read it with the elf implemented in the kernel
EOF
read

cat <<EOF
ELF have a LOT of option, one interesting is: PT_INTERP
PT_INTERP is a parametter of ELF format,
it enable to choose another useland ELF interpretter to handle currently read executable
compiller set this for every Dynamically compilled program
This is how ELF kernel reader fallback to /lib/ld-linux.so.2.

Reminder:
Static: 1 binary file load by kernel
Dynamic: multiple binaries files load by libc
EOF
read

cat <<EOF
Stuff to know:
- glibc is backward compatible (ELF compiled for linux 1.1.52 should work on modern distro)
- a program compiled on modern distro can not be read by an older ld-linux.so.2.
- ld-linux.so.2 is a static program, meaning it doesn't need libc to be installed to be executed and can be executed by the kernel directly
  - you can call ld-linux.so.2 directly, and use it to load a binary.
  - you can use a redent ld-linux.so.2 on an system having an older glibc.
- musl have it's own program loader "/ld-musl-x86_64.so.1".
- glibc/musl use some advence kernel features. and have a minimum kernel requirement. (using last glibc ld-linux.so.2 on old kernel won't work)
- when a program is dynamic, it require lib by they major version (so if it need libncursesw.so.6, it can't use libncursesw.so.6)
- when a program is compiled statically, the compiler put the whole libc and other lib in the binary.

most compiled languages use a libc (so /lib/ld-linux.so.2). go is the only exeption.


EOF
read

clear
cat <<EOF
Static vs Dynamic

------------------------------------------------------------------------------------------------------------------
 Dynamic						     |    Static
------------------------------------------------------------------------------------------------------------------
 Pro                                                         | Pro
------------------------------------------------------------------------------------------------------------------
 - share lib, less disk space                                | - Can't have dependancies issue
 - can fix security in 1 lib				     |    (but can still have too old kernel)
    without updating whole program			     | - more standard with go
 - more standard for C/C++				     |
------------------------------------------------------------------------------------------------------------------
 Con							     | con
------------------------------------------------------------------------------------------------------------------
 - missing dependancies (OS take care of lib)                | - a security issue, go repackage the whole program
 - missing old lib. (libX.so.2 instead of libX.so.1)         | - bloated (but who care ?)
 - lib ABI conflict. (but it's rare)                         |
------------------------------------------------------------------------------------------------------------------
EOF
read

cat <<EOF
Static vs Dynamic packaging it's own bianry loader.

--------------------------------------------------------------------------------------------
Dynamic + ld-linux.so.2                     | Static
--------------------------------------------------------------------------------------------
 pro			                    | pro
--------------------------------------------------------------------------------------------
 - can be made from any program using ldd   | faster to startup (like less than 1ms faster)
			                    | slightly smaller (like less than 10ko smaller)
--------------------------------------------------------------------------------------------
 con                                        | con
--------------------------------------------------------------------------------------------
 - need to create a script/                 | require .a libs.
    self extracted bin                      |
 - need to pay attention to lisence of libs |
--------------------------------------------------------------------------------------------

ther're mostly the same, seriously, if you don't live in the 90s (like ken), this debate is useless

for Dynamic + ld-linux.so.2, go see
https://gitlab.com/mojo42/mojopack/raw/master/mojopack.sh
http://joeyh.name/blog/entry/completely_linux_distribution-independent_packaging/

EOF
read

clear
cat <<EOF




                    | |
   ------------------------
  /   The real problem     \\
 |    _    _  of static    |
 |   /=\""/=\              |
 |  (=(0_0 |=)__           |
 |   \_\ _/_/   )    /--\\  |
 |     /_/   _  /\  |    | |
 |     |/ |\ || |   |    | |
 |       ~ ~  ~     |    | |
 ---------------------------
EOF
read
clear
tput setaf 2
cat <<EOF




                    | |
   -----------------------
  /    The real problem   \\
 |    _    _  of static    |
 |   /=\""/=\              |
 |  (=(0_0 |=)__           |
 |   \_\ _/_/ NV)    /--\\  |
 |     /_/ mesa /\  |    | |
 |     |/G|\ ||L|   |    | |
 |       ~ ~  ~     |    | |
 ---------------------------


[uso@ip-10-9-21-198 oapi-cli]$ ldd /usr/lib/libGL.so
        linux-vdso.so.1 (0x00007ffeda9da000)
        libGLdispatch.so.0 => /usr/lib/libGLdispatch.so.0 (0x00007f98126b0000)
        libGLX.so.0 => /usr/lib/libGLX.so.0 (0x00007f981267e000)
        libc.so.6 => /usr/lib/libc.so.6 (0x00007f9812497000)
        libX11.so.6 => /usr/lib/libX11.so.6 (0x00007f9812354000)
        /usr/lib64/ld-linux-x86-64.so.2 (0x00007f981280d000)
        libxcb.so.1 => /usr/lib/libxcb.so.1 (0x00007f9812329000)
        libXau.so.6 => /usr/lib/libXau.so.6 (0x00007f9812324000)
        libXdmcp.so.6 => /usr/lib/libXdmcp.so.6 (0x00007f981231a000)

EOF
tput sgr0
read

clear
cat <<EOF
Your new friend: LD_LIBRARY_PATH

LD_LIBRARY_PATH is use by ld-linux-x86-64.so.2
It set priority order to lib to load.
doesn't work for libc, but work for other lib
you can simply package your own lib, start your program with shell script setting LD_LIBRARY_PATH for you:
EOF
read

cat <<EOF
[uso@ip-10-9-21-198 presentation]$ ldd /bin/ls
        linux-vdso.so.1 (0x00007fff37f40000)
        libcap.so.2 => /usr/lib/libcap.so.2 (0x00007fdde573b000) <-- is in /usr/lib/
        libc.so.6 => /usr/lib/libc.so.6 (0x00007fdde5554000)
        /lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fdde578a000)
[uso@ip-10-9-21-198 presentation]$ ls lib*
libcap.so.2
[uso@ip-10-9-21-198 presentation]$ LD_LIBRARY_PATH=./ ldd /bin/ls
        linux-vdso.so.1 (0x00007ffcc02f7000)
        libcap.so.2 => ./libcap.so.2 (0x00007fc4a9530000)  <--- is in ./libcap.so.2
        libc.so.6 => /usr/lib/libc.so.6 (0x00007fc4a932c000)
        /lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fc4a9562000)



Major con of this methode, is that, glibc been backward compatible, a program package using this methode
will work only on system having a system with a glibc at last as recent as the one use to package your program.
So a thing package on the deprecated and outdated Debian 11 will work on the glorious Arch,
but the same thing package on the absolutely fabulous Arch Linux BTW, will not on the antique Debian 11.

https://gist.github.com/flibitijibibo/b67910842ab95bb3decdf89d1502de88
EOF

read

slide "BTW Appimage is basically LD_LIBRARY_PATH methode on steroide\n"

clear
cat <<EOF

                      (
                     (  ) (
                      )    )
         |||||||     (  ( (
        ( O   O )        )
 ____oOO___(_)___OOo____(
(_______________________)
           FLATPAK

It's like a system in the system.
Similar to LD_LIBRARY_PATH methode, but lib can be shared between multiples flatpak packages.

EOF

read

slide "The missing:\n" "deb/rpm other system package\n" "interpreted stuff (it's the interpretter job)"


